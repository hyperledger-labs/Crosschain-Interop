package com.r3.corda.evminterop.workflows.swap

import co.paralleluniverse.fibers.Suspendable
import com.r3.corda.evminterop.contracts.swap.LockCommand
import com.r3.corda.evminterop.states.swap.LockState
import com.r3.corda.evminterop.states.swap.UnlockData
import net.corda.core.contracts.Command
import net.corda.core.contracts.OwnableState
import net.corda.core.contracts.StateAndRef
import net.corda.core.flows.*
import net.corda.core.identity.Party
import net.corda.core.transactions.SignedTransaction
import net.corda.core.transactions.TransactionBuilder
import net.corda.core.utilities.ProgressTracker
import net.corda.core.utilities.loggerFor

/**
 * Initiating flow which transfers the Corda asset to the new owner (calling party) using proofs generated by
 * approved Corda validators.
 */
@StartableByRPC
@InitiatingFlow
class UnlockTransactionAndObtainAssetFlow(
    private val lockedAsset: StateAndRef<OwnableState>,
    private val lockState: StateAndRef<LockState>,
    private val unlockData: UnlockData,
    private val notary: Party
) : FlowLogic<SignedTransaction>() {


    @Suppress("ClassName")
    companion object {
        object BUILD_TRANSACTION : ProgressTracker.Step("Build transaction.")
        object VERIFY_TRANSACTION : ProgressTracker.Step("VERIFY_TRANSACTION")
        object SIGN_TRANSACTION : ProgressTracker.Step("SIGN_TRANSACTION")
        object NOTARIZE_TRANSACTION : ProgressTracker.Step("NOTARIZE_TRANSACTION")

        fun tracker() = ProgressTracker(
            BUILD_TRANSACTION,
            VERIFY_TRANSACTION,
            SIGN_TRANSACTION,
            NOTARIZE_TRANSACTION
        )

        val log = loggerFor<UnlockTransactionAndObtainAssetFlow>()
    }

    override val progressTracker: ProgressTracker = tracker()

    @Suspendable
    override fun call(): SignedTransaction {

        progressTracker.currentStep = BUILD_TRANSACTION

        val newOwner = serviceHub.identityService.partyFromKey(lockState.state.data.assetRecipient)
            ?: throw IllegalArgumentException("The specified recpient does not resolve to a known Party")

        val unlockCommand = Command(LockCommand.Unlock(unlockData), listOf(ourIdentity.owningKey))
        val builder = TransactionBuilder(notary = notary)
            .addInputState(lockedAsset)
            .addInputState(lockState)
            .addOutputState(lockedAsset.state.data.withNewOwner(newOwner).ownableState)
            .addCommand(unlockCommand)

        progressTracker.currentStep = VERIFY_TRANSACTION

        builder.verify(serviceHub)

        progressTracker.currentStep = SIGN_TRANSACTION

        val ptx = serviceHub.signInitialTransaction(builder)
        val stx = subFlow(CollectSignaturesFlow(ptx, emptySet()))

        progressTracker.currentStep = NOTARIZE_TRANSACTION

        val participantsSessions = (lockedAsset.state.data.participants - ourIdentity).map { initiateFlow(it) }
        return subFlow(FinalityFlow(stx, participantsSessions))
    }
}

@InitiatedBy(UnlockTransactionAndObtainAssetFlow::class)
class UnlockTransactionAndObtainAssetFlowResponder(val session: FlowSession) : FlowLogic<Unit>() {

    @Suspendable
    override fun call() {
        subFlow(ReceiveFinalityFlow(session))
    }
}