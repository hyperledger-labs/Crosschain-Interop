package com.r3.corda.evmbridge.workflows.swap

import co.paralleluniverse.fibers.Suspendable
import com.r3.corda.evmbridge.contracts.swap.LockCommand
import com.r3.corda.evmbridge.states.swap.LockState
import com.r3.corda.evmbridge.states.swap.TransferProof
import net.corda.core.contracts.Command
import net.corda.core.contracts.OwnableState
import net.corda.core.contracts.StateAndRef
import net.corda.core.flows.*
import net.corda.core.identity.Party
import net.corda.core.transactions.SignedTransaction
import net.corda.core.transactions.TransactionBuilder

/**
 * Initiating flow which transfers the Corda asset to the new owner (calling party) using proofs generated by
 * approved Corda validators.
 */
@StartableByRPC
@InitiatingFlow
class UnlockTransactionAndObtainAssetFlow(val lockedAsset: StateAndRef<OwnableState>,
                                          val lockState: StateAndRef<LockState>,
                                          val evmTransferProof: TransferProof,
                                          val notary: Party
) : FlowLogic<SignedTransaction>() {

    @Suspendable
    override fun call(): SignedTransaction {
        val unlockCommand = Command(LockCommand.Unlock(evmTransferProof), listOf(ourIdentity.owningKey))
        val builder = TransactionBuilder(notary = notary)
            .addInputState(lockedAsset)
            .addInputState(lockState)
            .addOutputState(lockedAsset.state.data.withNewOwner(ourIdentity).ownableState)
            .addCommand(unlockCommand)
        builder.verify(serviceHub)

        val ptx = serviceHub.signInitialTransaction(builder)
        val stx = subFlow(CollectSignaturesFlow(ptx, emptySet()))

        val participantsSessions = (lockedAsset.state.data.participants - ourIdentity).map { initiateFlow(it) }
        return subFlow(FinalityFlow(stx, participantsSessions))
    }
}

@InitiatedBy(UnlockTransactionAndObtainAssetFlow::class)
class UnlockTransactionAndObtainAssetFlowResponder(val session: FlowSession) : FlowLogic<Unit>() {

    @Suspendable
    override fun call() {
        subFlow(ReceiveFinalityFlow(session))
    }
}