const SECP256R1Verify = artifacts.require("SECP256R1Verify");
const ecKey = require('ec-key');
const truffleAssert = require('truffle-assertions');

contract("SECP256R1Verify", async accounts => {

  let instance = null;
  let messageHash;
  let message;
  let publicKey;
  let parity;
  let signature;

  beforeEach(async () => {
    instance = await SECP256R1Verify.new()

    let msg = Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 10);
    let buf = Buffer.from(msg, 'utf8')
    message = '0x' + buf.toString('hex');
    // Generate key
    let priKey = ecKey.createECKey('prime256v1');
    let pubKey = priKey.asPublicECKey();
    publicKey = ['0x' + pubKey.x.toString('hex'), '0x' + pubKey.y.toString('hex')];
    // Generate parity
    let asInt = BigInt(publicKey[1])
    let yBit = ((asInt >> 0n) & 1n) | 2n
    parity = '0x0'+ yBit.toString(16)
    // Generate signature
    let sigString = priKey.createSign('SHA256').update(msg).sign('hex').toString('hex');
    // Reformat signature / extract coordinates.
    let xlength = 2 * ('0x' + sigString.slice(6, 8));
    sigString = sigString.slice(8);
    let r = '0x' + sigString.slice(0, xlength)
    r = r.replace(/^(0x)0+((\w{4})+)$/, "$1$2")
    let s = '0x' + sigString.slice(xlength + 4)
    s = s.replace(/^(0x)0+((\w{4})+)$/, "$1$2")
    signature = [r, s];
  })

  it('should be able to verify valid signature', async () =>  {
    let result = await instance.verify(publicKey[0], signature[0], signature[1], parity, message);
    assert.equal(result, true);
  });

  it('should NOT be able to verify signature with zero signature value', async () =>  {
    let result = await instance.verify(publicKey[0], '0x0', signature[1], parity, message);
    assert.equal(result, false);
  });

  it('should NOT be able to verify signature with incorrect signature values', async () =>  {
    let result = await instance.verify(publicKey[0], '0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551', signature[1], parity, message);
    assert.equal(result, false);
  });

  it('should NOT be able to verify signature with malformed parity', async () => {
    await truffleAssert.reverts(
      instance.verify(publicKey[0], signature[0], signature[1], '0x09', message),
      'Invalid compressed EC point prefix'
    );
  });

  it('should NOT be able to verify signature with incorrect message', async () =>  {
    let result = await instance.verify(publicKey[0], signature[0], signature[1], parity, '0x1234');
    assert.equal(result, false);
  });

  it('should be able to verify valid signatures with even parity', async () =>  {
    let data1 = '0x636F7264610100000080C562000000000001D0000003D00000000300A3226E65742E636F7264613A4D5941396A726E4E646C5161615830366F45736D78413D3DC0770200A3226E65742E636F7264613A497A46743863524B7974734A713376512B796A7347673D3DC00502540B540300A3226E65742E636F7264613A37595A535555337443365976745833334B6C6F394A673D3DC02301A020A56831E5E71D2EF41D6B7286D795080FDBF93050D640A8DF0520BF96E592F2240080C562000000000002D00000031200000001D000000309000000040080C562000000000005C0E405A1226E65742E636F7264612E636F72652E63727970746F2E5369676E61626C654461746140450080C562000000000003C02602A3226E65742E636F7264613A4D5941396A726E4E646C5161615830366F45736D78413D3D40C089020080C562000000000004C04207A1117369676E61747572654D65746164617461A1276E65742E636F7264612E636F72652E63727970746F2E5369676E61747572654D6574616461746145404041420080C562000000000004C02E07A10474784964A1206E65742E636F7264612E636F72652E63727970746F2E5365637572654861736845404041420080C562000000000005C0B405A1276E65742E636F7264612E636F72652E63727970746F2E5369676E61747572654D6574616461746140450080C562000000000003C02602A3226E65742E636F7264613A497A46743863524B7974734A713376512B796A7347673D3D40C054020080C562000000000004C01E07A10F706C6174666F726D56657273696F6EA103696E7445A101304041420080C562000000000004C01D07A10E736368656D654E756D6265724944A103696E7445A101304041420080C562000000000005C0BB05A1206E65742E636F7264612E636F72652E63727970746F2E5365637572654861736840450080C562000000000003C02602A3226E65742E636F7264613A62373950654D424C73487875324132337944595261413D3D40C062030080C562000000000004C01507A1056279746573A10662696E61727945404041420080C562000000000004C01507A1066F6666736574A103696E7445A101304041420080C562000000000004C01307A10473697A65A103696E7445A101304041420080C562000000000005C08205A1276E65742E636F7264612E636F72652E63727970746F2E536563757265486173682453484132353640450080C562000000000003C02602A3226E65742E636F7264613A37595A535555337443365976745833334B6C6F394A673D3D40C022010080C562000000000004C01507A1056279746573A10662696E61727945404041420080C562000000000009C10100'
    let by1 = '0x48A450E7A340C810034F36C6CE78197CBEC20D123858813F7E27A881BDDFDCFA'
    let sigR1 = '0x963880C86872D7B986CA608F61A8ECC1E9A5F84EDCE93AA6D64BD1B3A568B687'
    let sigS1 = '0xC29CFB0F105318F884E858DF5AC8043C402F45ABF9ABF08BDCAE414FD14D8990'
    let sigV1 = '0x02'
    let result1 = await instance.verify(by1, sigR1, sigS1, sigV1, data1);
    assert.equal(result1, true);
    let data2 = '0x636F7264610100000080C562000000000001D0000003D00000000300A3226E65742E636F7264613A4D5941396A726E4E646C5161615830366F45736D78413D3DC0770200A3226E65742E636F7264613A497A46743863524B7974734A713376512B796A7347673D3DC00502540B540300A3226E65742E636F7264613A37595A535555337443365976745833334B6C6F394A673D3DC02301A0200BAED5ED8B8BA1A10432EF5CB62525868E5569B8E9088993990F69C78047C0DE0080C562000000000002D00000031200000001D000000309000000040080C562000000000005C0E405A1226E65742E636F7264612E636F72652E63727970746F2E5369676E61626C654461746140450080C562000000000003C02602A3226E65742E636F7264613A4D5941396A726E4E646C5161615830366F45736D78413D3D40C089020080C562000000000004C04207A1117369676E61747572654D65746164617461A1276E65742E636F7264612E636F72652E63727970746F2E5369676E61747572654D6574616461746145404041420080C562000000000004C02E07A10474784964A1206E65742E636F7264612E636F72652E63727970746F2E5365637572654861736845404041420080C562000000000005C0B405A1276E65742E636F7264612E636F72652E63727970746F2E5369676E61747572654D6574616461746140450080C562000000000003C02602A3226E65742E636F7264613A497A46743863524B7974734A713376512B796A7347673D3D40C054020080C562000000000004C01E07A10F706C6174666F726D56657273696F6EA103696E7445A101304041420080C562000000000004C01D07A10E736368656D654E756D6265724944A103696E7445A101304041420080C562000000000005C0BB05A1206E65742E636F7264612E636F72652E63727970746F2E5365637572654861736840450080C562000000000003C02602A3226E65742E636F7264613A62373950654D424C73487875324132337944595261413D3D40C062030080C562000000000004C01507A1056279746573A10662696E61727945404041420080C562000000000004C01507A1066F6666736574A103696E7445A101304041420080C562000000000004C01307A10473697A65A103696E7445A101304041420080C562000000000005C08205A1276E65742E636F7264612E636F72652E63727970746F2E536563757265486173682453484132353640450080C562000000000003C02602A3226E65742E636F7264613A37595A535555337443365976745833334B6C6F394A673D3D40C022010080C562000000000004C01507A1056279746573A10662696E61727945404041420080C562000000000009C10100'
    let by2 = '0x48A450E7A340C810034F36C6CE78197CBEC20D123858813F7E27A881BDDFDCFA'
    let sigR2 = '0xED1FB3E9662181EFBDC1203ABBF781C663ED078D9F975A40D3E214A5ED1FAC68'
    let sigS2 = '0x805F0C5A77271133AAE179CE9AC121BDC6B42DD257DE57B346BE41BFF79E0F24'
    let sigV2 = '0x02'
    let result2 = await instance.verify(by2, sigR2, sigS2, sigV2, data2);
    assert.equal(result2, true);
  });

  it('should NOT be able to verify signature with flipped public key coordinates ([x,y] >> [y,x])', async () =>  {
    let flippedPublicKey = [publicKey[1], publicKey[0]];
    let result = await instance.verifySignature(flippedPublicKey, signature, message);
    assert.equal(result, false);
  });

  it('should NOT be able to verify signature with flipped signature values ([r,s] >> [s,r])', async () =>  {
    let flippedSignature = [signature[1], signature[0]];
    let result = await instance.verifySignature(publicKey, flippedSignature, message);
    assert.equal(result, false);
  });

  it('should NOT be able to verify signature with invalid message hash', async () =>  {
    let invalidMsg = Math.random().toString(36).replace(/[^a-z]+/g, '').substring(0, 10);
    let imBuf = Buffer.from(invalidMsg, 'utf8')
    let invalidMessage = '0x' + imBuf.toString('hex');
    let result = await instance.verifySignature(publicKey, signature, invalidMessage);
    assert.equal(result, false);
  });
})
